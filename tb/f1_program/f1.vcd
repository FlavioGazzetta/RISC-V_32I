$version Generated by VerilatedVcd $end
$date Sat Dec  7 01:56:16 2024 $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire 32 h a0 [31:0] $end
  $var wire  1 e clk $end
  $var wire  1 f rst $end
  $var wire  1 g trigger $end
  $scope module f1 $end
   $var wire 32 m DATA_WIDTH [31:0] $end
   $var wire 32 h a0 [31:0] $end
   $var wire  1 e clk $end
   $var wire  1 $ delayed_clk $end
   $var wire  1 f rst $end
   $var wire  1 g trigger $end
   $var wire  1 # triggerRst $end
   $scope module clkdiv $end
    $var wire  1 e clkin $end
    $var wire  1 $ clkout $end
    $var wire  8 % count [7:0] $end
    $var wire  8 n delay [7:0] $end
    $var wire  1 f rst $end
   $upscope $end
   $scope module top $end
    $var wire 32 m ADDR_WIDTH [31:0] $end
    $var wire 32 m DATA_WIDTH [31:0] $end
    $var wire 32 m INSTR_WIDTH [31:0] $end
    $var wire 32 o MEM_ADDR_WIDTH [31:0] $end
    $var wire 32 q OFFSET [31:0] $end
    $var wire 32 p REG_DATA_WIDTH [31:0] $end
    $var wire 32 h a0 [31:0] $end
    $var wire  3 ) aluControl [2:0] $end
    $var wire 32 0 aluResult [31:0] $end
    $var wire  1 * aluSrc $end
    $var wire 32 l branchPC [31:0] $end
    $var wire  1 $ clk $end
    $var wire 32 ' immOp [31:0] $end
    $var wire  2 + immSrc [1:0] $end
    $var wire 32 < incPC [31:0] $end
    $var wire 32 9 instr [31:0] $end
    $var wire  1 , jalrSrc $end
    $var wire  1 - jumpSrc $end
    $var wire  1 2 memWrite $end
    $var wire 32 k nextPC [31:0] $end
    $var wire 32 8 pc [31:0] $end
    $var wire  1 . pcSrc $end
    $var wire 32 3 readData [31:0] $end
    $var wire 32 ; regOp2 [31:0] $end
    $var wire  1 ( regWrite $end
    $var wire 32 4 result [31:0] $end
    $var wire  1 1 resultSrc $end
    $var wire  1 f rst $end
    $var wire 32 : srcA [31:0] $end
    $var wire 32 / srcB [31:0] $end
    $var wire  1 # trigger $end
    $var wire 32 i wd3 [31:0] $end
    $var wire  1 j zero $end
    $scope module alu $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire  3 ) aluControl [2:0] $end
     $var wire 32 0 aluResult [31:0] $end
     $var wire 32 : srcA [31:0] $end
     $var wire 32 / srcB [31:0] $end
    $upscope $end
    $scope module aluMux $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire  1 * aluSrc $end
     $var wire 32 ' immOp [31:0] $end
     $var wire 32 ; regOp2 [31:0] $end
     $var wire 32 / srcB [31:0] $end
    $upscope $end
    $scope module branchUnit $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire  3 ) aluControl [2:0] $end
     $var wire 32 : srcA [31:0] $end
     $var wire 32 ; srcB [31:0] $end
     $var wire  1 j zero $end
    $upscope $end
    $scope module controlUnit $end
     $var wire  3 ) aluControl [2:0] $end
     $var wire  2 5 aluOp [1:0] $end
     $var wire  1 * aluSrc $end
     $var wire  3 > funct3 [2:0] $end
     $var wire  1 ? funct7 $end
     $var wire  2 + immSrc [1:0] $end
     $var wire  1 , jalrSrc $end
     $var wire  1 - jumpSrc $end
     $var wire  1 2 memWrite $end
     $var wire  7 = op [6:0] $end
     $var wire  1 . pcSrc $end
     $var wire  1 ( regWrite $end
     $var wire  1 1 resultSrc $end
     $var wire  1 j zero $end
     $scope module aluDecoder $end
      $var wire  3 ) aluControl [2:0] $end
      $var wire  2 5 aluOp [1:0] $end
      $var wire  3 > funct3 [2:0] $end
      $var wire  1 ? funct7 $end
      $var wire  1 @ op $end
      $var wire  2 A opfunct7 [1:0] $end
     $upscope $end
     $scope module mainDecoder $end
      $var wire  2 5 aluOp [1:0] $end
      $var wire  1 * aluSrc $end
      $var wire  2 + immSrc [1:0] $end
      $var wire  1 , jalrSrc $end
      $var wire  1 - jumpSrc $end
      $var wire  1 2 memWrite $end
      $var wire  7 = op [6:0] $end
      $var wire  1 . pcSrc $end
      $var wire  1 ( regWrite $end
      $var wire  1 1 resultSrc $end
      $var wire  1 j zero $end
     $upscope $end
    $upscope $end
    $scope module dataMemory $end
     $var wire 32 o ADDR_WIDTH [31:0] $end
     $var wire 17 6 ALUResult [16:0] $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire  1 2 MemWrite $end
     $var wire 32 3 ReadData [31:0] $end
     $var wire  3 > SizeCtr [2:0] $end
     $var wire 32 ; WriteData [31:0] $end
     $var wire  1 $ clk $end
    $upscope $end
    $scope module extend $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire 32 m INSTR_WIDTH [31:0] $end
     $var wire 32 ' immExt [31:0] $end
     $var wire  2 + immSrc [1:0] $end
     $var wire 32 9 instruction [31:0] $end
     $var wire  1 - jumpSrc $end
    $upscope $end
    $scope module extendPC $end
     $var wire 32 m ADDR_WIDTH [31:0] $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire 32 l branchPC [31:0] $end
     $var wire 32 ' immOp [31:0] $end
     $var wire  1 , jalrSrc $end
     $var wire 32 8 pc [31:0] $end
     $var wire 32 4 result [31:0] $end
    $upscope $end
    $scope module instrMemory $end
     $var wire 32 m ADDR_WIDTH [31:0] $end
     $var wire 32 m INSTR_WIDTH [31:0] $end
     $var wire 32 9 instr [31:0] $end
     $var wire 32 8 pc [31:0] $end
    $upscope $end
    $scope module jumpMux $end
     $var wire 32 i ALUout [31:0] $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire 32 < incPC [31:0] $end
     $var wire  1 - jumpSrc $end
     $var wire 32 4 result [31:0] $end
    $upscope $end
    $scope module pcMux $end
     $var wire 32 m ADDR_WIDTH [31:0] $end
     $var wire  1 . PCsrc $end
     $var wire 32 l branchPC [31:0] $end
     $var wire 32 < incPC [31:0] $end
     $var wire 32 k nextPC [31:0] $end
    $upscope $end
    $scope module pcReg $end
     $var wire 32 m ADDR_WIDTH [31:0] $end
     $var wire 32 q OFFSET [31:0] $end
     $var wire  1 $ clk $end
     $var wire 32 < incPC [31:0] $end
     $var wire 32 k nextPC [31:0] $end
     $var wire 32 8 pc [31:0] $end
     $var wire  1 f rst $end
    $upscope $end
    $scope module regFile $end
     $var wire 32 : ALUop1 [31:0] $end
     $var wire 32 i ALUout [31:0] $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire 32 p REG_DATA_WIDTH [31:0] $end
     $var wire  1 ( RegWrite $end
     $var wire 32 h a0 [31:0] $end
     $var wire  1 $ clk $end
     $var wire  5 D rd [4:0] $end
     $var wire 32 ; regOp2 [31:0] $end
     $var wire 32 E rom_array[0] [31:0] $end
     $var wire 32 O rom_array[10] [31:0] $end
     $var wire 32 P rom_array[11] [31:0] $end
     $var wire 32 Q rom_array[12] [31:0] $end
     $var wire 32 R rom_array[13] [31:0] $end
     $var wire 32 S rom_array[14] [31:0] $end
     $var wire 32 T rom_array[15] [31:0] $end
     $var wire 32 U rom_array[16] [31:0] $end
     $var wire 32 V rom_array[17] [31:0] $end
     $var wire 32 W rom_array[18] [31:0] $end
     $var wire 32 X rom_array[19] [31:0] $end
     $var wire 32 F rom_array[1] [31:0] $end
     $var wire 32 Y rom_array[20] [31:0] $end
     $var wire 32 Z rom_array[21] [31:0] $end
     $var wire 32 [ rom_array[22] [31:0] $end
     $var wire 32 \ rom_array[23] [31:0] $end
     $var wire 32 ] rom_array[24] [31:0] $end
     $var wire 32 ^ rom_array[25] [31:0] $end
     $var wire 32 _ rom_array[26] [31:0] $end
     $var wire 32 ` rom_array[27] [31:0] $end
     $var wire 32 a rom_array[28] [31:0] $end
     $var wire 32 b rom_array[29] [31:0] $end
     $var wire 32 G rom_array[2] [31:0] $end
     $var wire 32 c rom_array[30] [31:0] $end
     $var wire 32 d rom_array[31] [31:0] $end
     $var wire 32 H rom_array[3] [31:0] $end
     $var wire 32 I rom_array[4] [31:0] $end
     $var wire 32 J rom_array[5] [31:0] $end
     $var wire 32 K rom_array[6] [31:0] $end
     $var wire 32 L rom_array[7] [31:0] $end
     $var wire 32 M rom_array[8] [31:0] $end
     $var wire 32 N rom_array[9] [31:0] $end
     $var wire  5 B rs1 [4:0] $end
     $var wire  5 C rs2 [4:0] $end
    $upscope $end
    $scope module resultMux $end
     $var wire 32 0 ALUResult [31:0] $end
     $var wire 32 m DATA_WIDTH [31:0] $end
     $var wire 32 3 ReadData [31:0] $end
     $var wire 32 4 Result [31:0] $end
     $var wire  1 1 ResultSrc $end
    $upscope $end
   $upscope $end
   $scope module triggerFSM $end
    $var wire  1 e clk $end
    $var wire 32 & current_state [31:0] $end
    $var wire 32 7 next_state [31:0] $end
    $var wire  1 f rst $end
    $var wire  1 g trigger $end
    $var wire  1 # triggerRst $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
1#
0$
b00000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
0(
b000 )
0*
b00 +
0,
0-
0.
b00000000000000000000000000000000 /
b00000000000000000000000000000000 0
01
02
b00000000000000000000000000000000 3
b00000000000000000000000000000000 4
b00 5
b00000000000000000 6
b00000000000000000000000000000000 7
b00000000000000000000000000000000 8
b00000000000000000000000000000000 9
b00000000000000000000000000000000 :
b00000000000000000000000000000000 ;
b00000000000000000000000000000100 <
b0000000 =
b000 >
0?
0@
b00 A
b00000 B
b00000 C
b00000 D
b00000000000000000000000000000000 E
b00000000000000000000000000000000 F
b00000000000000000000000000000000 G
b00000000000000000000000000000000 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b00000000000000000000000000000000 L
b00000000000000000000000000000000 M
b00000000000000000000000000000000 N
b00000000000000000000000000000000 O
b00000000000000000000000000000000 P
b00000000000000000000000000000000 Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
b00000000000000000000000000000000 V
b00000000000000000000000000000000 W
b00000000000000000000000000000000 X
b00000000000000000000000000000000 Y
b00000000000000000000000000000000 Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
b00000000000000000000000000000000 ]
b00000000000000000000000000000000 ^
b00000000000000000000000000000000 _
b00000000000000000000000000000000 `
b00000000000000000000000000000000 a
b00000000000000000000000000000000 b
b00000000000000000000000000000000 c
b00000000000000000000000000000000 d
1e
0f
1g
b00000000000000000000000000000000 h
b00000000000000000000000000000000 i
1j
b00000000000000000000000000000100 k
b00000000000000000000000000000000 l
b00000000000000000000000000100000 m
b00001111 n
b00000000000000000000000000010001 o
b00000000000000000000000000000101 p
b00000000000000000000000000000100 q
